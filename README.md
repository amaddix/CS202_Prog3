# CS202_Prog3 / Ashley Maddix WinterQ 2018

For program 3, I’m tasked to create a program that will keep track of information on my phone apps (separating them by type of app). Allowing the user to add a new app, remove an app, display all apps, display all apps from a particular app type, remove all apps (and my program will also automatically read from a text file into the binary search tree, and save any new apps into the text file at the end of the program). I decided to organize my hierarchy with 4 classes. My base class will contain the general information about all apps (such as the title, purpose, qualities I enjoy, if I’ve spent money on it or not, and if I would recommend it to others). Derived from this class will be 3 classes for different types of apps and I will dynamically bind these classes, since they all share similar functionalities (and that way I can easily store them together in my binary search tree). One derived class will be about gaming apps, having an int for my high score, another int for the number of hours played on this game, and char * for what kind of game it is (such as racing game, mental game, and rhythm game). The second will be on social media apps, having data members for the number of followers, number of followers currently active, how long since you were last active. Lastly a class for educational/ school related apps, and this class will just have a char * to keep track of what subject it helps with. All the functions in my hierarchy will have a display, add and remove, (and most likely some function to insert/ read from a file) although I think I will try to implement the -, -=, << and >> operators in these function. For my base class I may also create the ==, !=, <, <=, >, >= operators to test the title of said app. In general I am hoping that by organizing my hierarchy in this way, by deriving my three app types from the general app class and dynamically binding them will help me to avoid a ton of setter and getter functions (since the derived classes can easily access their parents functions). My only concern with this is that I may end up needing some setter and getter functions to save into and read from my external text file.

Apart from my hierarchy I will create a node class that will have two node pointers (in order to point to the left and right of my tree), and a pointer to an app. This class will have the typical node classes such as set left, set right, get left, get right. It will also have a function to set the data (checking with the user which type of app they’re adding (or checking the file)) and then calling the appropriate class. I will most likely also have two display functions, one to just call the correct app- type display, and another to only display if our app pointer is pointing to the correct type (that the user wishes to display). Lastly I will have a class to manage my binary search tree, which will be organized alphabetically using the title of app (which is why I think it would be useful to implement the relational and equality operators in my base class). I will have a pointer to a node to save my tree.I will also have functions to insert into the tree, display the whole tree, display only one subject, remove everything from tree, remove one item, read from file, save into file. For a lot of these functions I’m gonna try to use operator overloading. For the insert I will probably implement the +, +=, ++, and for the remove -= and -, and for the displaying <<. 


EFFICIENCY WRITE UP: 	

For my third program, I organized my classes so that I had an base class controlling the general characteristics of a mobile app. And derived from the general app, I had three classes managing gaming apps, social media apps and school related apps. I made all three derived classes dynamically bond since they had similar functionality, and since this would make saving them into a data structure much easier. I think that the hierarchy of these classes works well for making this program object oriented, and unless more functionality was added to this program, I think it serves its purpose. 

The part of my program that was not object oriented way my binary search there and the nodes in it. I think that this data structure worked well for this program, since it allowed for being able to easily save all my apps in alphabetical order, and display them as so. However I do think that maybe by using an array of linear links lists, it may have been easier to find which apps were apart of which category. But then again, I do think binary search trees are a very efficient way to store our data, as long as we are wanting our data correctly sorted. If we did use an array of linear linked lists, it would have been much more work and transversal to sort our list correctly. So although that is a potential data type that could have been used in this program, reflecting on it some more I do believe that using a binary search tree was the better data structure for this program.

For the operator overloading portion, I made sure to use the = operator in each class using dynamic memory (along with the copy constructor). In my base class, and binary search tree I used the << operator to easily display the contents. In order for the base class to correctly call the derived class pointer, we called the app pointers display, when would display all the information from that class and call the base display again. In both the node class and base app class I also had all the equality and relational operators, so we could easily compare the title in the base app class. Lastly, in the binary search tree class, I included the += operator, and two + operator function, so we could insert a new node into our tree my saying my_tree=new_node. 

GDB WRITE UP

Once again, GDB has failed to disappoint! It proves so useful when debugging my program and making sure the correct functions are being called and the corrected data is being stored where it needs to be. In general, when testing my program, it's so useful to just run it in gdb in the first place. It prevents me from having to re enter all my data once i've opened gdb up, which really saves time.  It helped my figure out that my operation overloading functions were not actually being called ( explaining why my data was not being properly added in alphabetical order in my binary search tree). As i've been saying I would love for a way so that while i'm running gdb I don't have to re- run it but could just go back to a time before I entered a segfault (since it can be a pain re- entering all that data!). And I know i should probably go and look it up already, and see if there is actually a way for me to do that ( but I just keep putting it off). But with each program I find myself becoming more and more efficient at using gdb, and seeing the positive out comes that it has on my programs debugging process. 
